#version 450

// FluidSimulationKernels.glsl
// Scaling factors as uniform variables
uniform float Poly6ScalingFactor;
uniform float SpikyPow3ScalingFactor;
uniform float SpikyPow2ScalingFactor;
uniform float SpikyPow3DerivativeScalingFactor;
uniform float SpikyPow2DerivativeScalingFactor;

float SmoothingKernelPoly6(float dst, float radius) {
    if (dst < radius) {
        float v = radius * radius - dst * dst;
        return v * v * v * Poly6ScalingFactor;
    }
    return 0.0;
}

float SpikyKernelPow3(float dst, float radius) {
    if (dst < radius) {
        float v = radius - dst;
        return v * v * v * SpikyPow3ScalingFactor;
    }
    return 0.0;
}

float SpikyKernelPow2(float dst, float radius) {
    if (dst < radius) {
        float v = radius - dst;
        return v * v * SpikyPow2ScalingFactor;
    }
    return 0.0;
}

float DerivativeSpikyPow3(float dst, float radius) {
    if (dst <= radius) {
        float v = radius - dst;
        return -v * v * SpikyPow3DerivativeScalingFactor;
    }
    return 0.0;
}

float DerivativeSpikyPow2(float dst, float radius) {
    if (dst <= radius) {
        float v = radius - dst;
        return -v * SpikyPow2DerivativeScalingFactor;
    }
    return 0.0;
}

// gridHash.glsl

// Offsets for neighbor cells in a 2D grid
const ivec2 offsets2D[9] = ivec2[](
    ivec2(-1, 1),
    ivec2(0, 1),
    ivec2(1, 1),
    ivec2(-1, 0),
    ivec2(0, 0),
    ivec2(1, 0),
    ivec2(-1, -1),
    ivec2(0, -1),
    ivec2(1, -1)
);

// Constants used for hashing
const uint hashK1 = 15823u;
const uint hashK2 = 9737333u;

// Convert floating point position into an integer cell coordinate
ivec2 GetCell2D(vec2 position, float radius) {
    return ivec2(floor(position / radius));
}

// Hash cell coordinate to a single unsigned integer
uint HashCell2D(ivec2 cell) {
    uvec2 uCell = uvec2(cell);
    uint a = uCell.x * hashK1;
    uint b = uCell.y * hashK2;
    return a + b;
}

uint KeyFromHash(uint hash, uint tableSize) {
    return hash % tableSize;
}

// Constants
const int NumThreads = 64;

// Buffers
layout(std430, binding = 0) buffer PositionsBuffer { vec2 Positions[]; };
layout(std430, binding = 1) buffer PredictedPositionsBuffer { vec2 PredictedPositions[]; };
layout(std430, binding = 2) buffer VelocitiesBuffer { vec2 Velocities[]; };
layout(std430, binding = 3) buffer DensitiesBuffer { vec2 Densities[]; };
layout(std430, binding = 4) buffer SpatialIndicesBuffer { uvec3 SpatialIndices[]; };
layout(std430, binding = 5) buffer SpatialOffsetsBuffer { uint SpatialOffsets[]; };
layout(std430, binding = 6) buffer DebugBuffer { uint DebugValues[]; };


// Uniforms
uniform uint numParticles;
uniform float gravity;
uniform float deltaTime;
uniform float collisionDamping;
uniform float smoothingRadius;
uniform float targetDensity;
uniform float pressureMultiplier;
uniform float nearPressureMultiplier;
uniform float viscosityStrength;
uniform vec2 boundsSize;
uniform vec2 interactionInputPoint;
uniform float interactionInputStrength;
uniform float interactionInputRadius;
uniform vec2 obstacleSize;
uniform vec2 obstacleCentre;

// Utility Functions
float DensityKernel(float dst, float radius) {
    return SpikyKernelPow2(dst, radius);
}

float NearDensityKernel(float dst, float radius) {
    return SpikyKernelPow3(dst, radius);
}

float DensityDerivative(float dst, float radius) {
    return DerivativeSpikyPow2(dst, radius);
}

float NearDensityDerivative(float dst, float radius) {
    return DerivativeSpikyPow3(dst, radius);
}

float ViscosityKernel(float dst, float radius) {
    return SmoothingKernelPoly6(dst, smoothingRadius);
}

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearPressureMultiplier * nearDensity;
}

vec2 CalculateDensity(vec2 pos) {
    float sqrRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    // Iterate through all particles to compute density and near density
    for (uint i = 0; i < numParticles; i++) {
        vec2 neighbourPos = PredictedPositions[i];
        vec2 offsetToNeighbour = neighbourPos - pos;
        float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

        // Skip if not within radius
        if (sqrDstToNeighbour > sqrRadius) continue;

        // Calculate density and near density
        float dst = sqrt(sqrDstToNeighbour);
        density += DensityKernel(dst, smoothingRadius);
        nearDensity += NearDensityKernel(dst, smoothingRadius);
    }

    return vec2(density, nearDensity);
}

void HandleCollisions(uint particleIndex) {
    vec2 pos = Positions[particleIndex];
    vec2 vel = Velocities[particleIndex];

    // Keep particle inside bounds
    vec2 halfSize = boundsSize * 0.5;
    vec2 edgeDst = halfSize - abs(pos);

    if (edgeDst.x <= 0) {
        pos.x = halfSize.x * sign(pos.x);
        vel.x *= -1 * collisionDamping;
    }
    if (edgeDst.y <= 0) {
        pos.y = halfSize.y * sign(pos.y);
        vel.y *= -1 * collisionDamping;
    }

    float particleRadius = 1.0; 
    for (uint i = 0; i < numParticles; ++i) {
        if (i == particleIndex) continue;

        vec2 otherPos = Positions[i];
        vec2 delta = pos - otherPos;
        float distance = length(delta);

        if (distance < 2.0 * particleRadius) { // If particles are overlapping
            vec2 collisionNormal = normalize(delta);
            float overlap = 2.0 * particleRadius - distance;
            pos += collisionNormal * (overlap / 2.0);
            Positions[i] -= collisionNormal * (overlap / 2.0);

            vec2 relativeVelocity = vel - Velocities[i];
            float collisionImpulse = dot(relativeVelocity, collisionNormal);
            vec2 impulse = collisionImpulse * collisionNormal * collisionDamping;

            vel -= impulse;
            Velocities[i] += impulse;
        }
    }

    Positions[particleIndex] = pos;
    Velocities[particleIndex] = vel;
}


vec2 ExternalForces(vec2 pos, vec2 velocity) {
    // Gravity
    vec2 gravityAccel = vec2(0, gravity);

    // Input interactions modify gravity
    if (interactionInputStrength != 0) {
        vec2 inputPointOffset = interactionInputPoint - pos;
        float sqrDst = dot(inputPointOffset, inputPointOffset);
        if (sqrDst < interactionInputRadius * interactionInputRadius) {
            float dst = sqrt(sqrDst);
            float edgeT = (dst / interactionInputRadius);
            float centreT = 1 - edgeT;
            vec2 dirToCentre = inputPointOffset / dst;

            float gravityWeight = 1 - (centreT * clamp(interactionInputStrength / 10, 0.0, 1.0));
            vec2 accel = gravityAccel * gravityWeight + dirToCentre * centreT * interactionInputStrength;
            accel -= velocity * centreT;
            return accel;
        }
    }

    return gravityAccel;
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

void UpdateSpatialHashKernel(uint id) {
    if (id >= numParticles) return;

    DebugValues[id] = id;

    // Reset offsets
    SpatialOffsets[id] = numParticles;
    // Update index buffer
    uint index = id;
    ivec2 cell = GetCell2D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell2D(cell);
    uint key = KeyFromHash(hash, numParticles);
    SpatialIndices[id] = uvec3(index, hash, key);
    
    DebugValues[numParticles + id] = hash;
}

void CalculateDensitiesKernel(uint id) {
    if (id >= numParticles) return;

    vec2 pos = PredictedPositions[id];
    vec2 density = CalculateDensity(pos);
    Densities[id] = density;

    DebugValues[2 * numParticles + id] = floatBitsToUint(density.x);
    DebugValues[3 * numParticles + id] = floatBitsToUint(density.y);
}

void CalculatePressureForce(uint id) {
    if (id >= numParticles) return;

    float density = Densities[id][0];
    float densityNear = Densities[id][1];
    
    if (density <= 0.0) {
        DebugValues[6 * numParticles + id] = floatBitsToUint(-1.0);
        return;
    }
    
    float pressure = PressureFromDensity(density);
    float nearPressure = NearPressureFromDensity(densityNear);
    vec2 pressureForce = vec2(0.0);

    vec2 pos = PredictedPositions[id];
    float sqrRadius = smoothingRadius * smoothingRadius;

    // Neighbour search
    for (uint neighbourIndex = 0; neighbourIndex < numParticles; ++neighbourIndex) {
        // Skip if looking at self
        if (neighbourIndex == id) continue;

        vec2 neighbourPos = PredictedPositions[neighbourIndex];
        vec2 offsetToNeighbour = neighbourPos - pos;
        float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

        // Skip if not within radius
        if (sqrDstToNeighbour > sqrRadius) continue;

        // Calculate pressure force
        float dst = sqrt(sqrDstToNeighbour);
        if (dst <= 0.0) continue; 

        vec2 dirToNeighbour = offsetToNeighbour / dst;

        float neighbourDensity = Densities[neighbourIndex][0];
        float neighbourNearDensity = Densities[neighbourIndex][1];
        
        if (neighbourDensity <= 0.0) continue;

        float neighbourPressure = PressureFromDensity(neighbourDensity);
        float neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity);

        float sharedPressure = (pressure + neighbourPressure) * 0.5;
        float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

        pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;
        pressureForce += dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;
    }

    if (density > 0.0) {
        vec2 acceleration = pressureForce / density;
        Velocities[id] += acceleration * deltaTime;
    } else {
        DebugValues[6 * numParticles + id] = floatBitsToUint(-2.0); // Invalid density
    }
}


void CalculateViscosity(uint id) {
    if (id >= numParticles) return;

    vec2 pos = PredictedPositions[id];
    float sqrRadius = smoothingRadius * smoothingRadius;

    vec2 viscosityForce = vec2(0.0);
    vec2 velocity = Velocities[id];

    for (uint neighbourIndex = 0; neighbourIndex < numParticles; ++neighbourIndex) {
        // Skip if looking at self
        if (neighbourIndex == id) continue;

        vec2 neighbourPos = PredictedPositions[neighbourIndex];
        vec2 offsetToNeighbour = neighbourPos - pos;
        float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

        // Skip if not within radius
        if (sqrDstToNeighbour > sqrRadius) continue;

        float dst = sqrt(sqrDstToNeighbour);
        if (dst <= 0.0) continue; 

        vec2 neighbourVelocity = Velocities[neighbourIndex];
        viscosityForce += (neighbourVelocity - velocity) * ViscosityKernel(dst, smoothingRadius);
    }

    if (isnan(viscosityForce.x) || isnan(viscosityForce.y)) {
        DebugValues[6 * numParticles + id] = 0xFFFFFFFF; // Debugging particle
    } else {
        Velocities[id] += viscosityForce * viscosityStrength * deltaTime;
    }
}


void UpdatePositionsKernel(uint id) {
    if (id >= numParticles) return;

    Positions[id] += Velocities[id] * deltaTime;
    HandleCollisions(id);
    
    DebugValues[4 * numParticles + id] = floatBitsToUint(Positions[id].x);
    DebugValues[5 * numParticles + id] = floatBitsToUint(Positions[id].y);
}


void WriteDebugValues(uint id, vec2 pos, vec2 vel, vec2 predPos, uint marker) {
    uint idx = id * 8;
    DebugValues[idx] = id;
    DebugValues[idx + 1] = floatBitsToUint(pos.x);
    DebugValues[idx + 2] = floatBitsToUint(pos.y);
    DebugValues[idx + 3] = floatBitsToUint(vel.x);
    DebugValues[idx + 4] = floatBitsToUint(vel.y);
    DebugValues[idx + 5] = floatBitsToUint(predPos.x);
    DebugValues[idx + 6] = floatBitsToUint(predPos.y);
    DebugValues[idx + 7] = marker;
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    if (id < numParticles) {
        WriteDebugValues(id, Positions[id], Velocities[id], PredictedPositions[id], 1);
    }

    // Apply external forces and predict positions
    if (id < numParticles) {
        Velocities[id] += ExternalForces(Positions[id], Velocities[id]) * deltaTime;
        const float predictionFactor = 1.0 / 120.0;
        PredictedPositions[id] = Positions[id] + Velocities[id] * predictionFactor;
        WriteDebugValues(id, Positions[id], Velocities[id], PredictedPositions[id], 2);
    }

    barrier();

    //UpdateSpatialHashKernel(id);
    CalculateDensitiesKernel(id);
    CalculatePressureForce(id);
    CalculateViscosity(id);
    UpdatePositionsKernel(id);

    if (id < numParticles) {
        WriteDebugValues(id, Positions[id], Velocities[id], PredictedPositions[id], 3);
    }

}